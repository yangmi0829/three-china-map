{
  "version": 3,
  "sources": ["../three/examples/jsm/deprecated/Geometry.js"],
  "sourcesContent": ["import {\n\tBox3,\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tEventDispatcher,\n\tFloat32BufferAttribute,\n\tMatrix3,\n\tMatrix4,\n\tMathUtils,\n\tObject3D,\n\tSphere,\n\tVector2,\n\tVector3\n} from '../../../build/three.module.js';\n\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\n\nfunction Geometry() {\n\n\tthis.uuid = MathUtils.generateUUID();\n\n\tthis.name = '';\n\tthis.type = 'Geometry';\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.faces = [];\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\t// update flags\n\n\tthis.elementsNeedUpdate = false;\n\tthis.verticesNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\tthis.groupsNeedUpdate = false;\n\n}\n\nGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\n\n\tconstructor: Geometry,\n\n\tisGeometry: true,\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( let j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\tthis.verticesNeedUpdate = true;\n\t\tthis.normalsNeedUpdate = true;\n\n\t\treturn this;\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tscale: function ( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function ( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t},\n\n\tfromBufferGeometry: function ( geometry ) {\n\n\t\tconst scope = this;\n\n\t\tconst index = geometry.index !== null ? geometry.index : undefined;\n\t\tconst attributes = geometry.attributes;\n\n\t\tif ( attributes.position === undefined ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst position = attributes.position;\n\t\tconst normal = attributes.normal;\n\t\tconst color = attributes.color;\n\t\tconst uv = attributes.uv;\n\t\tconst uv2 = attributes.uv2;\n\n\t\tif ( uv2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\n\n\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\tscope.vertices.push( new Vector3().fromBufferAttribute( position, i ) );\n\n\t\t\tif ( color !== undefined ) {\n\n\t\t\t\tscope.colors.push( new Color().fromBufferAttribute( color, i ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addFace( a, b, c, materialIndex ) {\n\n\t\t\tconst vertexColors = ( color === undefined ) ? [] : [\n\t\t\t\tscope.colors[ a ].clone(),\n\t\t\t\tscope.colors[ b ].clone(),\n\t\t\t\tscope.colors[ c ].clone()\n\t\t\t];\n\n\t\t\tconst vertexNormals = ( normal === undefined ) ? [] : [\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, a ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, b ),\n\t\t\t\tnew Vector3().fromBufferAttribute( normal, c )\n\t\t\t];\n\n\t\t\tconst face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\n\n\t\t\tscope.faces.push( face );\n\n\t\t\tif ( uv !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( uv2 !== undefined ) {\n\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, a ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, b ),\n\t\t\t\t\tnew Vector2().fromBufferAttribute( uv2, c )\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst groups = geometry.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\t\t\tconst group = groups[ i ];\n\n\t\t\t\tconst start = group.start;\n\t\t\t\tconst count = group.count;\n\n\t\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\t\taddFace( index.getX( j ), index.getX( j + 1 ), index.getX( j + 2 ), group.materialIndex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\taddFace( j, j + 1, j + 2, group.materialIndex );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( index !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < index.count; i += 3 ) {\n\n\t\t\t\t\taddFace( index.getX( i ), index.getX( i + 1 ), index.getX( i + 2 ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i += 3 ) {\n\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeFaceNormals();\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function () {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\tthis.computeBoundingSphere();\n\n\t\tconst center = this.boundingSphere.center;\n\t\tconst radius = this.boundingSphere.radius;\n\n\t\tconst s = radius === 0 ? 1 : 1.0 / radius;\n\n\t\tconst matrix = new Matrix4();\n\t\tmatrix.set(\n\t\t\ts, 0, 0, - s * center.x,\n\t\t\t0, s, 0, - s * center.y,\n\t\t\t0, 0, s, - s * center.z,\n\t\t\t0, 0, 0, 1\n\t\t);\n\n\t\tthis.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted = true ) {\n\n\t\tconst vertices = new Array( this.vertices.length );\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst vA = this.vertices[ face.a ];\n\t\t\t\tconst vB = this.vertices[ face.b ];\n\t\t\t\tconst vC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeFlatVertexNormals: function () {\n\n\t\tthis.computeFaceNormals();\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tvertexNormals[ 0 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 1 ].copy( face.normal );\n\t\t\t\tvertexNormals[ 2 ].copy( face.normal );\n\n\t\t\t} else {\n\n\t\t\t\tvertexNormals[ 0 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 1 ] = face.normal.clone();\n\t\t\t\tvertexNormals[ 2 ] = face.normal.clone();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.faces.length > 0 ) {\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( let i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tconst tmpGeo = new Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( let i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tconst dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tconst dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tconst faceNormal = new Vector3();\n\t\t\t\t\tconst vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tconst face = this.faces[ f ];\n\n\t\t\t\tconst faceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tconst vertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( let f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tconst face = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\tmerge: function ( geometry, matrix, materialIndexOffset = 0 ) {\n\n\t\tif ( ! ( geometry && geometry.isGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet normalMatrix;\n\t\tconst vertexOffset = this.vertices.length,\n\t\t\tvertices1 = this.vertices,\n\t\t\tvertices2 = geometry.vertices,\n\t\t\tfaces1 = this.faces,\n\t\t\tfaces2 = geometry.faces,\n\t\t\tcolors1 = this.colors,\n\t\t\tcolors2 = geometry.colors;\n\n\t\tif ( matrix !== undefined ) {\n\n\t\t\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( let i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tconst vertex = vertices2[ i ];\n\n\t\t\tconst vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// colors\n\n\t\tfor ( let i = 0, il = colors2.length; i < il; i ++ ) {\n\n\t\t\tcolors1.push( colors2[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( let i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tconst face = faces2[ i ];\n\t\t\tlet normal, color;\n\t\t\tconst faceVertexNormals = face.vertexNormals,\n\t\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tconst faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix !== undefined ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( let j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( let i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs2 = geometry.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs2 = faceVertexUvs2[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs2.length; k < kl; k ++ ) {\n\n\t\t\t\t\tuvsCopy.push( uvs2[ k ].clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tmergeMesh: function ( mesh ) {\n\n\t\tif ( ! ( mesh && mesh.isMesh ) ) {\n\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( mesh.matrixAutoUpdate ) mesh.updateMatrix();\n\n\t\tthis.merge( mesh.geometry, mesh.matrix );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function ( precisionPoints = 4 ) {\n\n\t\tconst verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\t\tconst unique = [], changes = [];\n\n\t\tconst precision = Math.pow( 10, precisionPoints );\n\n\t\tfor ( let i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tconst v = this.vertices[ i ];\n\t\t\tconst key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tconst faceIndicesToRemove = [];\n\n\t\tfor ( let i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tconst indices = [ face.a, face.b, face.c ];\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( let n = 0; n < 3; n ++ ) {\n\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\n\t\t\tconst idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( let j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tconst diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tthis.vertices = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsortFacesByMaterialIndex: function () {\n\n\t\tconst faces = this.faces;\n\t\tconst length = faces.length;\n\n\t\t// tag faces\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tfaces[ i ]._id = i;\n\n\t\t}\n\n\t\t// sort faces\n\n\t\tfunction materialIndexSort( a, b ) {\n\n\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t}\n\n\t\tfaces.sort( materialIndexSort );\n\n\t\t// sort uvs\n\n\t\tconst uvs1 = this.faceVertexUvs[ 0 ];\n\t\tconst uvs2 = this.faceVertexUvs[ 1 ];\n\n\t\tlet newUvs1, newUvs2;\n\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tconst id = faces[ i ]._id;\n\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\n\n\t\t}\n\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\n\n\t},\n\n\ttoJSON: function () {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Geometry',\n\t\t\t\tgenerator: 'Geometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard Geometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tconst vertices = [];\n\n\t\tfor ( let i = 0; i < this.vertices.length; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t}\n\n\t\tconst faces = [];\n\t\tconst normals = [];\n\t\tconst normalsHash = {};\n\t\tconst colors = [];\n\t\tconst colorsHash = {};\n\t\tconst uvs = [];\n\t\tconst uvsHash = {};\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tconst hasMaterial = true;\n\t\t\tconst hasFaceUv = false; // deprecated\n\t\t\tconst hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\n\t\t\tconst hasFaceNormal = face.normal.length() > 0;\n\t\t\tconst hasFaceVertexNormal = face.vertexNormals.length > 0;\n\t\t\tconst hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n\t\t\tconst hasFaceVertexColor = face.vertexColors.length > 0;\n\n\t\t\tlet faceType = 0;\n\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\n\n\t\t\tfaces.push( faceType );\n\t\t\tfaces.push( face.a, face.b, face.c );\n\t\t\tfaces.push( face.materialIndex );\n\n\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\tconst faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\t\tfaces.push(\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction setBit( value, position, enabled ) {\n\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\n\n\t\t}\n\n\t\tfunction getNormalIndex( normal ) {\n\n\t\t\tconst hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn normalsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\treturn normalsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getColorIndex( color ) {\n\n\t\t\tconst hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn colorsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tcolorsHash[ hash ] = colors.length;\n\t\t\tcolors.push( color.getHex() );\n\n\t\t\treturn colorsHash[ hash ];\n\n\t\t}\n\n\t\tfunction getUvIndex( uv ) {\n\n\t\t\tconst hash = uv.x.toString() + uv.y.toString();\n\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\n\n\t\t\t\treturn uvsHash[ hash ];\n\n\t\t\t}\n\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\n\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\treturn uvsHash[ hash ];\n\n\t\t}\n\n\t\tdata.data = {};\n\n\t\tdata.data.vertices = vertices;\n\t\tdata.data.normals = normals;\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\n\t\tdata.data.faces = faces;\n\n\t\treturn data;\n\n\t},\n\n\tclone: function () {\n\n\t\t/*\n\t\t // Handle primitives\n\n\t\t const parameters = this.parameters;\n\n\t\t if ( parameters !== undefined ) {\n\n\t\t const values = [];\n\n\t\t for ( const key in parameters ) {\n\n\t\t values.push( parameters[ key ] );\n\n\t\t }\n\n\t\t const geometry = Object.create( this.constructor.prototype );\n\t\t this.constructor.apply( geometry, values );\n\t\t return geometry;\n\n\t\t }\n\n\t\t return new this.constructor().copy( this );\n\t\t */\n\n\t\treturn new Geometry().copy( this );\n\n\t},\n\n\tcopy: function ( source ) {\n\n\t\t// reset\n\n\t\tthis.vertices = [];\n\t\tthis.colors = [];\n\t\tthis.faces = [];\n\t\tthis.faceVertexUvs = [[]];\n\t\tthis.morphTargets = [];\n\t\tthis.morphNormals = [];\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\t\tthis.lineDistances = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// vertices\n\n\t\tconst vertices = source.vertices;\n\n\t\tfor ( let i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\t// colors\n\n\t\tconst colors = source.colors;\n\n\t\tfor ( let i = 0, il = colors.length; i < il; i ++ ) {\n\n\t\t\tthis.colors.push( colors[ i ].clone() );\n\n\t\t}\n\n\t\t// faces\n\n\t\tconst faces = source.faces;\n\n\t\tfor ( let i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\t// face vertex uvs\n\n\t\tfor ( let i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tconst faceVertexUvs = source.faceVertexUvs[ i ];\n\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\n\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tconst uvs = faceVertexUvs[ j ], uvsCopy = [];\n\n\t\t\t\tfor ( let k = 0, kl = uvs.length; k < kl; k ++ ) {\n\n\t\t\t\t\tconst uv = uvs[ k ];\n\n\t\t\t\t\tuvsCopy.push( uv.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// morph targets\n\n\t\tconst morphTargets = source.morphTargets;\n\n\t\tfor ( let i = 0, il = morphTargets.length; i < il; i ++ ) {\n\n\t\t\tconst morphTarget = {};\n\t\t\tmorphTarget.name = morphTargets[ i ].name;\n\n\t\t\t// vertices\n\n\t\t\tif ( morphTargets[ i ].vertices !== undefined ) {\n\n\t\t\t\tmorphTarget.vertices = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( morphTargets[ i ].normals !== undefined ) {\n\n\t\t\t\tmorphTarget.normals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.push( morphTarget );\n\n\t\t}\n\n\t\t// morph normals\n\n\t\tconst morphNormals = source.morphNormals;\n\n\t\tfor ( let i = 0, il = morphNormals.length; i < il; i ++ ) {\n\n\t\t\tconst morphNormal = {};\n\n\t\t\t// vertex normals\n\n\t\t\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.vertexNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\n\t\t\t\t\tconst destVertexNormal = {};\n\n\t\t\t\t\tdestVertexNormal.a = srcVertexNormal.a.clone();\n\t\t\t\t\tdestVertexNormal.b = srcVertexNormal.b.clone();\n\t\t\t\t\tdestVertexNormal.c = srcVertexNormal.c.clone();\n\n\t\t\t\t\tmorphNormal.vertexNormals.push( destVertexNormal );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// face normals\n\n\t\t\tif ( morphNormals[ i ].faceNormals !== undefined ) {\n\n\t\t\t\tmorphNormal.faceNormals = [];\n\n\t\t\t\tfor ( let j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\n\n\t\t\t\t\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.morphNormals.push( morphNormal );\n\n\t\t}\n\n\t\t// skin weights\n\n\t\tconst skinWeights = source.skinWeights;\n\n\t\tfor ( let i = 0, il = skinWeights.length; i < il; i ++ ) {\n\n\t\t\tthis.skinWeights.push( skinWeights[ i ].clone() );\n\n\t\t}\n\n\t\t// skin indices\n\n\t\tconst skinIndices = source.skinIndices;\n\n\t\tfor ( let i = 0, il = skinIndices.length; i < il; i ++ ) {\n\n\t\t\tthis.skinIndices.push( skinIndices[ i ].clone() );\n\n\t\t}\n\n\t\t// line distances\n\n\t\tconst lineDistances = source.lineDistances;\n\n\t\tfor ( let i = 0, il = lineDistances.length; i < il; i ++ ) {\n\n\t\t\tthis.lineDistances.push( lineDistances[ i ] );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// update flags\n\n\t\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\n\t\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\n\t\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\n\t\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\n\t\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n\t\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\n\n\t\treturn this;\n\n\t},\n\n\ttoBufferGeometry: function () {\n\n\t\tconst geometry = new DirectGeometry().fromGeometry( this );\n\n\t\tconst buffergeometry = new BufferGeometry();\n\n\t\tconst positions = new Float32Array( geometry.vertices.length * 3 );\n\t\tbuffergeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\n\n\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\tconst normals = new Float32Array( geometry.normals.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\n\n\t\t}\n\n\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\tconst colors = new Float32Array( geometry.colors.length * 3 );\n\t\t\tbuffergeometry.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\tconst uvs = new Float32Array( geometry.uvs.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\n\n\t\t}\n\n\t\tif ( geometry.uvs2.length > 0 ) {\n\n\t\t\tconst uvs2 = new Float32Array( geometry.uvs2.length * 2 );\n\t\t\tbuffergeometry.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\n\n\t\t}\n\n\t\t// groups\n\n\t\tbuffergeometry.groups = geometry.groups;\n\n\t\t// morphs\n\n\t\tfor ( const name in geometry.morphTargets ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphTargets = geometry.morphTargets[ name ];\n\n\t\t\tfor ( let i = 0, l = morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ i ];\n\n\t\t\t\tconst attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );\n\t\t\t\tattribute.name = morphTarget.name;\n\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget.data ) );\n\n\t\t\t}\n\n\t\t\tbuffergeometry.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\t// skinning\n\n\t\tif ( geometry.skinIndices.length > 0 ) {\n\n\t\t\tconst skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\n\n\t\t}\n\n\t\tif ( geometry.skinWeights.length > 0 ) {\n\n\t\t\tconst skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\n\t\t\tbuffergeometry.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn buffergeometry;\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeTangents() has been removed.' );\n\n\t},\n\n\tcomputeLineDistances: function () {\n\n\t\tconsole.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tconsole.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );\n\t\treturn this.applyMatrix4( matrix );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n} );\n\nGeometry.createBufferGeometryFromObject = function ( object ) {\n\n\tlet buffergeometry = new BufferGeometry();\n\n\tconst geometry = object.geometry;\n\n\tif ( object.isPoints || object.isLine ) {\n\n\t\tconst positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\n\t\tconst colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\n\n\t\tbuffergeometry.setAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\n\t\tbuffergeometry.setAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\n\n\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\n\n\t\t\tconst lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\n\n\t\t\tbuffergeometry.setAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\n\n\t\t}\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tbuffergeometry.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tbuffergeometry.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t} else if ( object.isMesh ) {\n\n\t\tbuffergeometry = geometry.toBufferGeometry();\n\n\t}\n\n\treturn buffergeometry;\n\n};\n\nclass DirectGeometry {\n\n\tconstructor() {\n\n\t\tthis.vertices = [];\n\t\tthis.normals = [];\n\t\tthis.colors = [];\n\t\tthis.uvs = [];\n\t\tthis.uvs2 = [];\n\n\t\tthis.groups = [];\n\n\t\tthis.morphTargets = {};\n\n\t\tthis.skinWeights = [];\n\t\tthis.skinIndices = [];\n\n\t\t// this.lineDistances = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// update flags\n\n\t\tthis.verticesNeedUpdate = false;\n\t\tthis.normalsNeedUpdate = false;\n\t\tthis.colorsNeedUpdate = false;\n\t\tthis.uvsNeedUpdate = false;\n\t\tthis.groupsNeedUpdate = false;\n\n\t}\n\n\tcomputeGroups( geometry ) {\n\n\t\tconst groups = [];\n\n\t\tlet group, i;\n\t\tlet materialIndex = undefined;\n\n\t\tconst faces = geometry.faces;\n\n\t\tfor ( i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// materials\n\n\t\t\tif ( face.materialIndex !== materialIndex ) {\n\n\t\t\t\tmaterialIndex = face.materialIndex;\n\n\t\t\t\tif ( group !== undefined ) {\n\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\t\t\tgroups.push( group );\n\n\t\t\t\t}\n\n\t\t\t\tgroup = {\n\t\t\t\t\tstart: i * 3,\n\t\t\t\t\tmaterialIndex: materialIndex\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( group !== undefined ) {\n\n\t\t\tgroup.count = ( i * 3 ) - group.start;\n\t\t\tgroups.push( group );\n\n\t\t}\n\n\t\tthis.groups = groups;\n\n\t}\n\n\tfromGeometry( geometry ) {\n\n\t\tconst faces = geometry.faces;\n\t\tconst vertices = geometry.vertices;\n\t\tconst faceVertexUvs = geometry.faceVertexUvs;\n\n\t\tconst hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\n\t\tconst hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\n\n\t\t// morphs\n\n\t\tconst morphTargets = geometry.morphTargets;\n\t\tconst morphTargetsLength = morphTargets.length;\n\n\t\tlet morphTargetsPosition;\n\n\t\tif ( morphTargetsLength > 0 ) {\n\n\t\t\tmorphTargetsPosition = [];\n\n\t\t\tfor ( let i = 0; i < morphTargetsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsPosition[ i ] = {\n\t\t\t\t\tname: morphTargets[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\n\n\t\t}\n\n\t\tconst morphNormals = geometry.morphNormals;\n\t\tconst morphNormalsLength = morphNormals.length;\n\n\t\tlet morphTargetsNormal;\n\n\t\tif ( morphNormalsLength > 0 ) {\n\n\t\t\tmorphTargetsNormal = [];\n\n\t\t\tfor ( let i = 0; i < morphNormalsLength; i ++ ) {\n\n\t\t\t\tmorphTargetsNormal[ i ] = {\n\t\t\t\t\tname: morphNormals[ i ].name,\n\t\t\t\t \tdata: []\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\n\n\t\t}\n\n\t\t// skins\n\n\t\tconst skinIndices = geometry.skinIndices;\n\t\tconst skinWeights = geometry.skinWeights;\n\n\t\tconst hasSkinIndices = skinIndices.length === vertices.length;\n\t\tconst hasSkinWeights = skinWeights.length === vertices.length;\n\n\t\t//\n\n\t\tif ( vertices.length > 0 && faces.length === 0 ) {\n\n\t\t\tconsole.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\n\n\t\t\tconst vertexNormals = face.vertexNormals;\n\n\t\t\tif ( vertexNormals.length === 3 ) {\n\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst normal = face.normal;\n\n\t\t\t\tthis.normals.push( normal, normal, normal );\n\n\t\t\t}\n\n\t\t\tconst vertexColors = face.vertexColors;\n\n\t\t\tif ( vertexColors.length === 3 ) {\n\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\n\n\t\t\t} else {\n\n\t\t\t\tconst color = face.color;\n\n\t\t\t\tthis.colors.push( color, color, color );\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 0 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\n\n\t\t\t\t\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasFaceVertexUv2 === true ) {\n\n\t\t\t\tconst vertexUvs = faceVertexUvs[ 1 ][ i ];\n\n\t\t\t\tif ( vertexUvs !== undefined ) {\n\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\n\n\t\t\t\t\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// morphs\n\n\t\t\tfor ( let j = 0; j < morphTargetsLength; j ++ ) {\n\n\t\t\t\tconst morphTarget = morphTargets[ j ].vertices;\n\n\t\t\t\tmorphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0; j < morphNormalsLength; j ++ ) {\n\n\t\t\t\tconst morphNormal = morphNormals[ j ].vertexNormals[ i ];\n\n\t\t\t\tmorphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );\n\n\t\t\t}\n\n\t\t\t// skins\n\n\t\t\tif ( hasSkinIndices ) {\n\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\n\n\t\t\t}\n\n\t\t\tif ( hasSkinWeights ) {\n\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.computeGroups( geometry );\n\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n\t\tif ( geometry.boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\n\n\t\t}\n\n\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nclass Face3 {\n\n\tconstructor( a, b, c, normal, color, materialIndex = 0 ) {\n\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\tthis.c = c;\n\n\t\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\n\n\t\tthis.color = ( color && color.isColor ) ? color : new Color();\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\n\n\t\tthis.materialIndex = materialIndex;\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.a = source.a;\n\t\tthis.b = source.b;\n\t\tthis.c = source.c;\n\n\t\tthis.normal.copy( source.normal );\n\t\tthis.color.copy( source.color );\n\n\t\tthis.materialIndex = source.materialIndex;\n\n\t\tfor ( let i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\n\n\t\t}\n\n\t\tfor ( let i = 0, il = source.vertexColors.length; i < il; i ++ ) {\n\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { Face3, Geometry };\n"],
  "mappings": "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",
  "names": []
}
